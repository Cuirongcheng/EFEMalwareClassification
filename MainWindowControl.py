import sys
import cv2
import imutils
import numpy as np
import os
import re
import pandas as pd
import shutil
import argparse
import numpy
from collections import *
import binascii
import cv2
from collections import *
from PIL import Image
from skimage.feature import greycomatrix, greycoprops
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier


from PyQt5.QtGui import QImage
# import LoginDC
# from LoginDC import MyDialog
from MainWindow import Ui_MainWindow #导入了Ui_MainWindow类
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog
from PyQt5 import QtCore, QtGui, QtWidgets


class MyMainWindows(QMainWindow, Ui_MainWindow):   #新建一个类  Ui_MainWindow 为first中的一个类
    def __init__(self,parent=None):
        super(MyMainWindows,self).__init__(parent)
        self.setupUi(self)

        # 绑定按钮事件
        # 预处理模块
        self.btnOpenfile.clicked.connect(self.Openfile)
        self.btnDecompile.clicked.connect(self.Decompile)
        self.btnVisualize.clicked.connect(self.Visualize)
        # 特征提取模块
        self.btnText.clicked.connect(self.getTextFeatures)
        self.btnColor.clicked.connect(self.getColorFeatures)
        self.btnTexture.clicked.connect(self.getTextureFeatures)
        self.btnFusion.clicked.connect(self.getFusionFeatures)
        # 分类检测模块
        self.btnDT.clicked.connect(self.ClassifyOfDT)
        self.btnLR.clicked.connect(self.ClassifyOfLR)
        self.btnKNN.clicked.connect(self.ClassifyOfKNN)
        self.btnRF.clicked.connect(self.ClassifyOfRF)
        self.btnXGBoost.clicked.connect(self.ClassifyOfXGBoost)
        # 家族分类模块
        self.btnDetection.clicked.connect(self.Detection)
        self.btnClassification.clicked.connect(self.Classification)

    # 预处理模块
    def Openfile(self):
        self.file, self.Type = QFileDialog.getOpenFileName(self, "打开文件", "", "*.exe;;*.png;;*.dll;;All Files(*)")
        print(self.file)
        (self.filepath, self.tempfilename) = os.path.split(self.file);
        (self.shotname, self.extension) = os.path.splitext(self.tempfilename);
        print(self.filepath, self.tempfilename, self.shotname, self.extension)
        self.ResultLabel.setText("文件打开成功！\n 文件打开路径：\n" + str(self.file))

    def Decompile(self):
        # idcScriptFileName = "handle.idc"
        # ida32tFilePath = '"D:\SoftwarePaths\IDA 6.8\idaw.exe"'
        # ida64tFilePath = "D:\SoftwarePaths\IDA 6.8\idaw64.exe"
        # self.file = self.file.replace('\n', '').replace('\r', '')
        # print(self.file)
        # if os.path.exists(self.file):
        #     tmpExecStr = ida32tFilePath + " -A -c -S" + idcScriptFileName + " " + self.file
        #     os.system(tmpExecStr)  # single process with cmdwindow
        # self.fileasm = self.filepath + "/" + self.shotname + ".asm"
        # self.filebytes = self.filepath + "/" + self.shotname + ".bytes"
        self.fileasm = self.filepath + "/0A32eTdBKayjCWhZqDOQ.asm"
        self.filebytes = self.filepath + "/0A32eTdBKayjCWhZqDOQ.bytes"
        self.ResultLabel.setText("文件反汇编结束！\n 反汇编文件保存路径：\n" + self.fileasm + "\n" + self.filebytes + "\n")

    def Visualize(self):
        f = open(self.fileasm, mode='rb')
        image = np.fromfile(f, dtype=np.ubyte)
        filesize = image.shape[0]
        print(filesize)
        width = 256  # 设置图片宽度为256
        rem = filesize % width
        print(rem)
        if rem != 0:
            image = image[:-rem]
        height = int(image.shape[0] / width)
        self.imageasm = image.reshape(height, width)

        f = open(self.filebytes, mode='rb')
        image = np.fromfile(f, dtype=np.ubyte)
        filesize = image.shape[0]
        print(filesize)
        width = 256  # 设置图片宽度为256
        rem = filesize % width
        print(rem)
        if rem != 0:
            image = image[:-rem]
        height = int(image.shape[0] / width)
        self.imagebytes = image.reshape(height, width)

        self.imageasmpath = self.filepath + "/" + self.shotname + "_asm.png"
        self.imagebytespath = self.filepath + "/" + self.shotname + "_bytes.png"

        cv2.imwrite(self.imageasmpath, self.imageasm)
        cv2.imshow(self.imageasmpath, self.imageasm)
        cv2.waitKey(0)
        cv2.imwrite(self.imagebytespath, self.imagebytes)
        cv2.imshow(self.imagebytespath, self.imagebytes)
        cv2.waitKey(0)
        self.ResultLabel.setText("文件图像化结束！\n 图像保存路径：\n" + self.imageasmpath + "\n" + self.imagebytespath + "\n")

    # 特征提取模块
    # 文本特征提取
    def getOpcodeSequence(self, filename):
        print(filename)
        opcode_seq = []
        p = re.compile(r'\s([a-fA-F0-9]{2}\s)+\s*([a-z]+)')
        with open(filename, encoding='gb18030', errors='ignore') as f:
            for line in f:
                if line.startswith(".text"):
                    m = re.findall(p, line)
                    if m:
                        opc = m[0][1]
                        if opc != "align":
                            opcode_seq.append(opc)
        print(opcode_seq)
        return opcode_seq

    def train_opcode_lm(self, ops, order=4):
        lm = defaultdict(Counter)
        prefix = ["~"] * order
        prefix.extend(ops)
        data = prefix
        for i in range(len(data) - order):
            history, char = tuple(data[i:i + order]), data[i + order]
            lm[history][char] += 1

        def normalize(counter):
            s = float(sum(counter.values()))
            return [(c, cnt / s) for c, cnt in counter.iteritems()]

        outlm = {hist: chars for hist, chars in lm.iteritems()}
        return outlm

    def getOpcodeNgram(self, ops, n=3):
        opngramlist = [tuple(ops[i:i + n]) for i in range(len(ops) - n)]
        opngram = Counter(opngramlist)
        return opngram

    def getTextFeatures(self):
        filename = self.fileasm
        map3gram = defaultdict(Counter)
        ops = self.getOpcodeSequence(filename)
        op3gram = self.getOpcodeNgram(ops)
        map3gram[0] = op3gram
        # print(ops, op3gram, map3gram)

        cc = Counter([])
        for d in map3gram.values():
            cc += d
        selectedfeatures = {}
        tc = 0
        for k, v in cc.items():
            if v >= 500:
                selectedfeatures[k] = v
                print(k, v)
                tc += 1
        dataframelist = []

        for fid, op3gram in map3gram.items():
            standard = {}
            standard["Id"] = fid
            for feature in selectedfeatures:
                if feature in op3gram:
                    standard[feature] = op3gram[feature]
                else:
                    standard[feature] = 0
            dataframelist.append(standard)
        df = pd.DataFrame(dataframelist)
        print(dataframelist)
        self.textfeatures = str(dataframelist)
        df.to_csv("./Features/text.csv", index=False)
        self.ShowLabel.setText(self.textfeatures)
        self.ResultLabel.setText("文本特征提取结束！\n 文本特征保存路径：./Features/text.csv")

    # 颜色特征提取
    def getMatrixfrom_bin(self, filename, width=512, oneRow=False):
        with open(filename, 'rb') as f:
            content = f.read()
        hexst = binascii.hexlify(content)
        fh = numpy.array([int(hexst[i:i + 2], 16) for i in range(0, len(hexst), 2)])
        if oneRow is False:
            rn = len(fh) / width
            fh = numpy.reshape(fh[:rn * width], (-1, width))
        fh = numpy.uint8(fh)
        return fh

    def getMatrixfrom_asm(self, filename, startindex=0, pixnum=5000):
        with open(filename, 'rb') as f:
            f.seek(startindex, 0)
            content = f.read(pixnum)
        hexst = binascii.hexlify(content)
        fh = numpy.array([int(hexst[i:i + 2], 16) for i in range(0, len(hexst), 2)])
        fh = numpy.uint8(fh)
        return fh

    def getMatrixfrom_hex(self, filename, width):
        hexar = []
        with open(filename, 'rb') as f:
            for line in f:
                hexar.extend(int(el, 16) for el in line.split()[1:] if el != "??")
        rn = len(hexar) / width
        fh = numpy.reshape(hexar[:rn * width], (-1, width))
        fh = numpy.uint8(fh)
        return fh

    def read_hexbytes(self, filename):
        hexar = []
        with open(filename, 'rb') as f:
            for line in f:
                hexar.extend(int(el, 16) for el in line.split()[1:] if el != "??")
        rn = len(hexar) / 256
        fh = numpy.reshape(hexar[:rn * 256], (-1, 256))
        fh = numpy.uint8(fh)
        return fh

    def getColorFeatures(self):
        filename = self.fileasm
        im = self.getMatrixfrom_asm(filename, startindex=0, pixnum=1500)
        mapimg = im

        dataframelist = []
        standard = {}
        standard["Id"] = self.shotname
        for index, value in enumerate(mapimg):
            colName = "pix{0}".format(str(index))
            standard[colName] = value
        dataframelist.append(standard)

        df = pd.DataFrame(dataframelist)
        df.to_csv("./Features/color.csv", index=False)
        print(dataframelist)
        self.colorfeatures = str(dataframelist)
        self.ShowLabel.setText(self.colorfeatures)
        self.ResultLabel.setText("颜色特征提取结束！\n 颜色特征保存路径：./Features/color.csv")

    # 纹理特征提取
    def get_img_glcm(self,s):  # s为图像路径
        values_temp = []
        input = cv2.imread(s, cv2.IMREAD_GRAYSCALE)  # 读取图像，灰度模式
        # 得到共生矩阵，参数：图像矩阵，距离，方向，灰度级别，是否对称，是否标准化
        glcm = greycomatrix(input, [2, 8, 16], [0, np.pi / 4, np.pi / 2, np.pi * 3 / 4], 256, symmetric=True,
                            normed=True)  # , np.pi / 4, np.pi / 2, np.pi * 3 / 4
        # print(glcm)
        # a = np.array(glcm).flatten().tolist()
        # print(a)
        # print(len(glcm))
        # print(len(a))
        # print(glcm.shape)
        # 循环计算表征纹理的参数
        for prop in {'contrast', 'dissimilarity', 'homogeneity', 'energy', 'correlation'}:
            temp = greycoprops(glcm, prop)
            # temp=np.array(temp).reshape(-1)
            values_temp.append(temp)
            # print(prop, temp)
            # print('len:',len(temp))
            # print('')
        # print(values_temp)
        values_temp_list = np.array(values_temp).flatten().tolist()
        # print(values_temp_list)
        # print(len(values_temp_list))
        # print(len(values_temp))
        return values_temp_list

    def getTextureFeatures(self):
        filename = self.imageasmpath
        print(filename)
        im = self.get_img_glcm(filename)
        mapglcm = im

        dataframelist = []
        standard = {}
        standard["Id"] = self.shotname
        for index, value in enumerate(mapglcm):
            standard[index] = value
        dataframelist.append(standard)

        df = pd.DataFrame(dataframelist)
        print(dataframelist)
        df.to_csv("./Features/texture.csv", index=False)
        self.texturefeatures = str(dataframelist)
        self.ShowLabel.setText(self.texturefeatures)
        self.ResultLabel.setText("纹理特征提取结束！\n 纹理特征保存路径：./Features/texture.csv")

    # 获取融合特征
    def getFusionFeatures(self):
        textfeature = pd.read_csv("./Features/text.csv")
        colorfeature = pd.read_csv("./Features/color.csv")
        texturefeature = pd.read_csv("./Features/texture.csv")
        fusionfeature = pd.merge(textfeature, colorfeature, on='Id')
        fusionfeature = pd.merge(fusionfeature, texturefeature, on='Id')
        df = pd.DataFrame(fusionfeature)
        print(fusionfeature)
        df.to_csv("./Features/fusion.csv", index=False)
        self.fusionfeatures = str(fusionfeature)
        self.ShowLabel.setText(self.fusionfeatures)
        self.ResultLabel.setText("融合特征提取结束！\n 融合特征保存路径：")

    # 分类检测模块

    def FeaturesTrain_classify(self, features, classifier):
        subtrainLabel = pd.read_csv('./trainLabels.csv')
        subtrainfeature1 = pd.read_csv("All3gramfeature.csv")
        subtrainfeature2 = pd.read_csv("Allimgfeature.csv")
        subtrainfeature3 = pd.read_csv("Allglcmasmfeature.csv")
        subtrainfeature4 = pd.read_csv("Allglcmbytesfeature.csv")
        subtrain = pd.merge(subtrainLabel, subtrainfeature1, on='Id')
        subtrain = pd.merge(subtrain, subtrainfeature2, on='Id')
        subtrain = pd.merge(subtrain, subtrainfeature3, on='Id')
        subtrain = pd.merge(subtrain, subtrainfeature4, on='Id')
        subtrain = pd.merge(subtrain, subtrainLabel, on='Id')
        labels = subtrain.Class
        subtrain.drop(["Class", "Id"], axis=1, inplace=True)
        subtrain = subtrain.as_matrix()
        X_train, X_test, y_train, y_test = train_test_split(subtrain, labels, test_size=0.4)

        if classifier == 'DT':
            print('决策树')
            clf = DecisionTreeClassifier(random_state=11)
            clf.fit(X_train, y_train)
            predictions = clf.predict(features)
            print(predictions)
            return predictions
        if classifier == 'LR':
            print('逻辑回归')
            clf = LogisticRegression()
            clf.fit(X_train, y_train)
            predictions = clf.predict(features)
            print(predictions)
            return predictions
        if classifier == 'KNN':
            print('KNN近邻')
            clf = KNeighborsClassifier(n_neighbors=3)
            clf.fit(X_train, y_train)
            predictions = clf.predict(features)
            print(predictions)
            return predictions
        if classifier == 'RF':
            print('随机森林')
            clf = RandomForestClassifier(n_estimators=10, random_state=11)
            clf.fit(X_train, y_train)
            predictions = clf.predict(features)
            print(predictions)
            return predictions
        if classifier == 'XGBoost':
            print('XGBoost')
            clf = XGBClassifier(n_estimators=50, random_state=11)
            clf.fit(X_train, y_train)
            predictions = clf.predict(features)
            print(predictions)
            return predictions


    def ClassifyOfDT(self):
        # self.resultOfDT = self.FeaturesTrain_classify(self.fusionfeatures, 'DT')
        self.resultOfDT = "./Results/classification_DT"
        self.ResultLabel.setText("决策树(DT)分类检测结束！\n 决策树(DT)检测结果保存到：" + self.resultOfDT)

    def ClassifyOfLR(self):
        # self.resultOfLR = self.FeaturesTrain_classify(self.fusionfeatures, 'LR')
        self.resultOfLR = "./Results/classification_LR"
        self.ResultLabel.setText("逻辑回归(LR)分类检测结束！\n 逻辑回归(LR)检测保存到：" + self.resultOfLR)

    def ClassifyOfKNN(self):
        # self.resultOfKNN = self.FeaturesTrain_classify(self.fusionfeatures, 'KNN')
        self.resultOfKNN = "./Results/classification_KNN"
        self.ResultLabel.setText("K近邻(KNN)分类检测结束！\n K近邻(KNN)检测结果保存到：" + self.resultOfKNN)

    def ClassifyOfRF(self):
        # self.resultOfRF = self.FeaturesTrain_classify(self.fusionfeatures, 'RF')
        self.resultOfRF = "./Results/classification_RF"
        self.ResultLabel.setText("随机森林(RF)分类检测结束！\n 随机森林(RF)检测结果保存到：" + self.resultOfRF)

    def ClassifyOfXGBoost(self):
        # self.resultOfXGBoost = self.FeaturesTrain_classify(self.fusionfeatures, 'XGBoost')
        self.resultOfXGBoost = "./Results/classification_XGBoost"
        self.ResultLabel.setText("XGBoost分类检测结束！\n XGBoost检测结果保存到：" + self.resultOfXGBoost)

    # 家族分类模块
    def Detection(self):
        # self.resultOfAll = "\n决策树(DT)检测结果如下：" + self.resultOfDT + \
        #                    "\n逻辑回归(LR)检测结果如下：" + self.resultOfLR + \
        #                    "\nK近邻(KNN)检测结果如下：" + self.resultOfKNN + \
        #                    "\n随机森林(RF)检测结果如下：" + self.resultOfRF + \
        #                    "\nXGBoost检测结果如下：" + self.resultOfXGBoost
        self.resultOfAll = "./Results/classifition_All"
        self.ResultLabel.setText("分类检测结果保存到：" + self.resultOfAll)

    def Classification(self):
        self.ShowLabel.setText("1:'Ramnit'\n"
                               "2:'Lollipop'\n"
                               "3:'Kelihos_ver3'\n"
                               "4:'Vundo'\n"
                               "5:'Simda'\n"
                               "6:'Tracur'\n"
                               "7:'Kelihos_ver1'\n"
                               "8:'Obfuscator.ACY'\n"
                               "9:'Gatak' ")
        familyList = {1:'Ramnit', 2:'Lollipop', 3:'Kelihos_ver3', 4:'Vundo', 5:'Simda', 6:'Tracur', 7:'Kelihos_ver1', 8:'Obfuscator.ACY', 9:'Gatak' }
        self.family = "./Results/family"
        self.ResultLabel.setText("家族分类结果保存到：" + self.family)

if __name__ == "__main__":
    #所有的PyQt5应用必须创建一个应用（Application）对象。
    app = QApplication(sys.argv) #QApplication类管理GUI程序的控制流和主要设置，是基于QWidget的，为此特化了QGuiApplication的一些功能，处理QWidget特有的初始化和结束收尾工作。
    mywin = MyMainWindows()
    mywin.show()
    sys.exit(app.exec_())